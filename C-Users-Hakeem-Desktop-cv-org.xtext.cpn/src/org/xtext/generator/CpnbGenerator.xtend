/*
 * generated by Xtext 2.10.0
 */
package org.xtext.generator

import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.cpnb.Containement
import org.xtext.cpnb.Model
import org.xtext.cpnb.Opr
import org.xtext.cpnb.Placedec
import org.xtext.cpnb.Transitiondeclation
import org.xtext.cpnb.color
import org.xtext.cpnb.inialisation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CpnbGenerator extends AbstractGenerator {
    
	override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var filename = res.contents.filter(typeof(Model)).get(0)
		
	fsa.generateFile('B-Method/'+filename.name+".Approche1", compileB(filename, 1))
	fsa.generateFile('B-Method/'+filename.name+".Approche2", compileB(filename, 2))
	//fsa.generateFile('B-Method/'+filename.name+".Approche3", compileB(filename, 3))
	fsa.generateFile('Event-B/'+filename.name+".Context", compileEB(filename, 0))
	fsa.generateFile('Event-B/'+filename.name+".Approche1", compileEB(filename, 1))
	fsa.generateFile('Event-B/'+filename.name+".Approche2", compileEB(filename, 2))
    //fsa.generateFile('Event-B/'+filename.name+".Approche3", compileEB(filename, 3))
	}
	
	def compileB(Model model, int i){	
		if(i==1)
		'''
		MACHINE «model.name»
		SETS
		«FOR Places : model.placesDeclaration»
				Color_«Places.name» = {«Places.colors.compile(0)» }
		«ENDFOR»
		DEF
		Ms(ss) == ss ** NAT
		Ms_empty(ss) == {elt|elt : ss**{0}}
		VARIABLES
				«FOR Place : model.placesDeclaration»State_«Place.name», «ENDFOR»
				«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 1)»«ENDFOR»
				«model.trasitionsDeclaration.compileTr(1)»
		INVARIANTS
				«FOR Place : model.placesDeclaration»State_«Place.name» :: MS(Color_«Place.name»), «ENDFOR»
				«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 2)»«ENDFOR»
				«model.trasitionsDeclaration.compileTr(2)»
		INITIALISATION
		«FOR init:  model.init SEPARATOR ',\n'»
		«FOR elt: init.elements SEPARATOR ',\n'» occ_«elt.colr.name»_«init.pl.name» := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		«FOR color: init.pl.colors SEPARATOR ',\n'» «color.bcompilenotdeclaredcolors(init)»«ENDFOR»
		«FOR elt: init.elements SEPARATOR ',\n'» State_«init.pl.name»(«elt.colr.name») := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		«ENDFOR»
		«FOR Place : model.placesDeclaration SEPARATOR ',\n'» «bcompilenotdeclaredcolorsandplace(Place, model.init)»«ENDFOR»
		«FOR trans : model.trasitionsDeclaration SEPARATOR ',\n'» Enabled_«trans.name» := FALSE«ENDFOR»
		
		OPERATIONS
				«FOR trans : model.gardsdefintion»
				OP_Enabled_«trans.tr.name» = 
					PRE «FOR con : trans.ifs»«con.compile(1)»«ENDFOR» T 
					THEN Enabled_«trans.tr.name» := TRUE
				«ENDFOR»
				END;
				«FOR trans : model.gardsdefintion»
				OP_FIRED_«trans.tr.name» = 
					SELECT «FOR con : trans.ifs»«con.compile(1)»«ENDFOR» Enabled_«trans.tr.name» == TRUE
					THEN «FOR opr : trans.thens»«opr.compile(1)»«opr.compile(2)»«ENDFOR»Enabled_«trans.tr.name» := FALSE
				«ENDFOR»
				END;
		END		
		'''
		else if(i==2)
		'''
		MACHINE «model.name»
		SETS
		«FOR Places : model.placesDeclaration»
		        Color_«Places.name» = {«FOR color : Places.colors SEPARATOR ','»«color.name»«ENDFOR» }
				«ENDFOR»
		DEF
		Ms(ss) == ss ** NAT
		Ms_empty(ss) == {elt|elt : ss**{0}}
		VARIABLES
				«FOR Place : model.placesDeclaration»State_«Place.name», «ENDFOR»
				«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 1)»«ENDFOR»
				«model.trasitionsDeclaration.compileTr(1)»
		INVARIANTS
				«FOR Place : model.placesDeclaration»State_«Place.name» :: MS(Color_«Place.name»), «ENDFOR»
				«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 2)»«ENDFOR»
				«model.trasitionsDeclaration.compileTr(2)»
		INITIALISATION
		«FOR init:  model.init SEPARATOR ',\n'» 
		«FOR elt: init.elements SEPARATOR ',\n'» occ_«elt.colr.name»_«init.pl.name» := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		«FOR color: init.pl.colors SEPARATOR ',\n'» «color.bcompilenotdeclaredcolors(init)»«ENDFOR»
		«FOR elt: init.elements SEPARATOR ',\n'» State_«init.pl.name»(«elt.colr.name») := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		«ENDFOR»
		«FOR Place : model.placesDeclaration SEPARATOR ',\n'» «bcompilenotdeclaredcolorsandplace(Place, model.init)»«ENDFOR»
		«FOR trans : model.trasitionsDeclaration SEPARATOR ',\n'» Enabled_«trans.name» := FALSE«ENDFOR»
		
		OPERATIONS
				«FOR trans : model.gardsdefintion»
				OP_Enabled_«trans.tr.name» = 
				  PRE  «FOR con : trans.ifs SEPARATOR ' \n&'» «FOR elt: con.elements SEPARATOR ' & '»(«elt.colr.name» |-> «IF elt.counted == true» «elt.count.toString»«ELSE»1«ENDIF»):State_«con.state.name» =>«ENDFOR»
				       «ENDFOR»
				  THEN Enabled_«trans.tr.name» := TRUE
				«ENDFOR»
				END;
				«FOR trans : model.gardsdefintion»
				OP_FIRED_«trans.tr.name» = 
				    SELECT  «FOR con : trans.ifs SEPARATOR ' \n&'»«FOR elt: con.elements SEPARATOR ' & '»occ_«elt.colr.name»_«con.state.name» >= «IF elt.counted == true» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
				    	    & «FOR elt: con.elements SEPARATOR ' & '»(«elt.colr.name» |-> «IF elt.counted == true» «elt.count.toString»«ELSE»1«ENDIF»):State_«con.state.name» =>«ENDFOR»
				    		«ENDFOR»& Enabled_«trans.tr.name» == TRUE
				     THEN «FOR opr : trans.thens»«opr.compile(1)»«opr.compile(2)»«ENDFOR»Enabled_«trans.tr.name» := FALSE
				«ENDFOR»
				END;
		END	
		'''
	}
	
	
	
		def compileEB(Model model, int i){
		if(i==0)
		'''
		context «model.name»
		sets
		Colors
		constants
		«FOR Places : model.placesDeclaration»
		Color_«Places.name»
		«ENDFOR»
		«model.placesDeclaration.compilecolors(1)»
		axioms
		@axiom Partition(Colors, «model.placesDeclaration.compilecolors(2)»}
		«FOR Place : model.placesDeclaration»
		@axiom_«Place.name» Colors_«Place.name» : Colors
		@axiom«Place.name» Partition(Color_«Place.name»,«Place.colors.compile(1)»)
		«ENDFOR»
		end
		'''
		else if(i==1)
		'''
		machine «model.name»mac
		sees «model.name»
		variables
		«FOR Place : model.placesDeclaration»State_«Place.name», «ENDFOR»
		«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 3)»«ENDFOR»
		«model.trasitionsDeclaration.compileTr(3)»
		invariants
		«FOR Place : model.placesDeclaration»State_«Place.name» : Color_«Place.name» <-> NAT, «ENDFOR»
		«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 4)»«ENDFOR»
		«model.trasitionsDeclaration.compileTr(4)»
		events
		event INITIALISATION extends INITIALISATION
		            then
		            «FOR init:  model.init SEPARATOR '\n'» 
		            «FOR elt: init.elements SEPARATOR '\n'»@act_«elt.colr.name»_«init.pl.name» occ_«elt.colr.name»_«init.pl.name» := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		            «FOR color: init.pl.colors SEPARATOR '\n'» «color.compilenotdeclaredcolors(init)»«ENDFOR»
		            «FOR elt: init.elements SEPARATOR '\n'»@act2_«elt.colr.name»_«init.pl.name» State_«init.pl.name»(«elt.colr.name») := «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		            «ENDFOR»
		            «FOR Place : model.placesDeclaration SEPARATOR '\n'» «compilenotdeclaredcolorsandplace(Place, model.init)»«ENDFOR»
		            «FOR trans : model.trasitionsDeclaration SEPARATOR '\n'»@act_«trans.name» Enabled_«trans.name» := FALSE«ENDFOR»
		            end
		«FOR trans : model.gardsdefintion»
		event OP_Enabled_«trans.tr.name»
				   when
				    «FOR con : trans.ifs»
				    «con.compile(3)»
				    «ENDFOR»
				   then
				   @actn Enabled_«trans.tr.name» := TRUE
		«ENDFOR»
		           end
		«FOR trans : model.gardsdefintion»
		event OP_FIRED_«trans.tr.name»
				   when 
				   «FOR con : trans.ifs»
				   «con.compile(3)»
				   «ENDFOR» 
				   @gardn Enabled_«trans.tr.name» == TRUE
				   then «FOR opr : trans.thens»«opr.compileEB(1)»«opr.compileEB(2)»«ENDFOR»Enabled_«trans.tr.name» := FALSE
				«ENDFOR»
			       end
		end
		'''
		else if(i==2)
		'''
		machine «model.name»mac
		sees «model.name»
		variables
		«FOR Place : model.placesDeclaration»State_«Place.name» «ENDFOR»
		«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 3)»«ENDFOR»
		«model.trasitionsDeclaration.compileTr(3)»
		invariants
		«FOR Place : model.placesDeclaration SEPARATOR '\n'»@inv_«Place.name» State_«Place.name» : Color_«Place.name» <-> NAT «ENDFOR»
		«FOR Place : model.placesDeclaration»«Place.colors.compile(Place, 4)»«ENDFOR»
		«model.trasitionsDeclaration.compileTr(4)»
		events
		event INITIALISATION extends INITIALISATION
		            then
		            «FOR init:  model.init SEPARATOR '\n'» 
		            «FOR elt: init.elements SEPARATOR '\n'»@act_«elt.colr.name»_«init.pl.name» occ_«elt.colr.name»_«init.pl.name» := «IF elt.counted == 1»«elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		            «FOR color: init.pl.colors SEPARATOR '\n'» «color.compilenotdeclaredcolors(init)»«ENDFOR»
		            «FOR elt: init.elements SEPARATOR '\n'»@act2_«elt.colr.name»_«init.pl.name» State_«init.pl.name»(«elt.colr.name») := «IF elt.counted == 1»«elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
		            «ENDFOR»
		            «FOR Place : model.placesDeclaration SEPARATOR '\n'»«compilenotdeclaredcolorsandplace(Place, model.init)»«ENDFOR»
		            «FOR trans : model.trasitionsDeclaration SEPARATOR '\n'»@act_«trans.name» Enabled_«trans.name» := FALSE«ENDFOR»
		            end
		«FOR trans : model.gardsdefintion»
		event OP_Enabled_«trans.tr.name»
		           any «FOR con : trans.ifs SEPARATOR '\n '»«FOR elt: con.elements SEPARATOR ', '»r_«elt.colr.name»_«con.state.name»«ENDFOR»
		           	   «ENDFOR»
				   where
				    «FOR con : trans.ifs SEPARATOR '\n '»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard_«elt.colr.name»_«con.state.name» r_«elt.colr.name»_«con.state.name» >= «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard2_«elt.colr.name»_«con.state.name» (r_«elt.colr.name»_«con.state.name» |-> «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF») : State_«con.state.name» «ENDFOR»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard3_«elt.colr.name»_«con.state.name» occ_«elt.colr.name»_«con.state.name» >= «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
				    «ENDFOR»
				   then
				   @actn Enabled_«trans.tr.name» := TRUE
		«ENDFOR»
		           end
		«FOR trans : model.gardsdefintion»
		event OP_FIRED_«trans.tr.name»
		           any «FOR con : trans.ifs SEPARATOR ', '»«FOR elt: con.elements SEPARATOR ', '»r_«elt.colr.name»_«con.state.name»«ENDFOR»«ENDFOR»
				       «FOR opr : trans.thens SEPARATOR ', '»«IF opr.op=="\\/"» «FOR elt: opr.elements SEPARATOR ', '»r_«elt.colr.name»_«opr.states.get(0).name»«ENDFOR»«ENDIF»«ENDFOR»
				   where
				    «FOR con : trans.ifs SEPARATOR '\n '»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard_«elt.colr.name»_«con.state.name» r_«elt.colr.name»_«con.state.name» : NAT«ENDFOR»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard1_«elt.colr.name»_«con.state.name» r_«elt.colr.name»_«con.state.name» >= «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard2_«elt.colr.name»_«con.state.name» («elt.colr.name» |-> r_«elt.colr.name»_«con.state.name» ) : State_«con.state.name» «ENDFOR»
				    «FOR elt: con.elements SEPARATOR '\n '»@gard3_«elt.colr.name»_«con.state.name» occ_«elt.colr.name»_«con.state.name» >= «IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
				    «ENDFOR»
				    «FOR opr : trans.thens SEPARATOR '\n '»«IF opr.op=="\\/"» «FOR elt: opr.elements SEPARATOR '\n '»@gardo1_«elt.colr.name»_«opr.states.get(0).name»r_«elt.colr.name»_«opr.states.get(0).name» : NAT«ENDFOR»«ENDIF»«ENDFOR»
				    «FOR opr : trans.thens SEPARATOR '\n '»«IF opr.op=="\\/"» «FOR elt: opr.elements SEPARATOR '\n '»@gardo2_«elt.colr.name»_«opr.states.get(0).name» («elt.colr.name» |-> r_«elt.colr.name»_«opr.states.get(0).name» ) : State_«opr.states.get(0).name» «ENDFOR»«ENDIF»«ENDFOR»
				    @gardn Enabled_«trans.tr.name» == TRUE
				   then «FOR opr : trans.thens SEPARATOR '\n '»
                        «FOR elt: opr.elements SEPARATOR '\n ' »@act_«elt.colr.name»_«opr.states.get(0).name» occ_«elt.colr.name»_«opr.states.get(0).name» := occ_«elt.colr.name»_«opr.states.get(0).name»«IF opr.op =='\\/'» + «ELSE» - «ENDIF»«IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
                        «FOR elt: opr.elements SEPARATOR '\n ' »@act1_«elt.colr.name»_«opr.states.get(0).name» r_«elt.colr.name»_«opr.states.get(0).name» := r_«elt.colr.name»_«opr.states.get(0).name»«IF opr.op =='\\/'» + «ELSE» - «ENDIF»«IF elt.counted == 1» «elt.count.toString»«ELSE»1«ENDIF»«ENDFOR»
                        «FOR elt: opr.elements SEPARATOR '\n ' »@act2_«elt.colr.name»_«opr.states.get(0).name» State_«opr.states.get(0).name»( «elt.colr.name» ) := r_«elt.colr.name»_«opr.states.get(0).name»«ENDFOR»
                        «ENDFOR»
				        @actn Enabled_«trans.tr.name» := FALSE
				«ENDFOR»		
		        end
		end        
		'''
        }
	
	def compilenotdeclaredcolorsandplace( Placedec placed, EList<inialisation> list){
		var ST = ''''''
		var ArrayList<Placedec> place = new ArrayList<Placedec>()
		for(init: list){
			place.add(init.pl)
			}
        if(!place.contains(placed)){
        	ST+='''«FOR col: placed.colors SEPARATOR '\n'»@act_«col.name»_«placed.name» occ_«col.name»_«placed.name» := 0«ENDFOR»
«FOR col: placed.colors SEPARATOR '\n'» @act2_«col.name»_«placed.name» State_«placed.name»(«col.name») := 0«ENDFOR»'''
        	}
        return ST
		}
		
	def  bcompilenotdeclaredcolorsandplace( Placedec placed, EList<inialisation> list){
		var ST = ''''''
		var ArrayList<Placedec> place = new ArrayList<Placedec>()
		for(init: list){
			place.add(init.pl)
			}
        if(!place.contains(placed)){
        	ST+='''«FOR col: placed.colors SEPARATOR ',\n'» occ_«col.name»_«placed.name» := 0«ENDFOR»
«FOR col: placed.colors SEPARATOR ',\n'» State_«placed.name»(«col.name») := 0«ENDFOR»'''
        	}
        return ST
		
	}
	
	def  bcompilenotdeclaredcolors(color col, inialisation init){
		var ST = ''''''
		var ArrayList<color> colors = new ArrayList<color>()
		for(elt: init.elements){
			colors.add(elt.colr)
			}
        if(!colors.contains(col)){
        	ST+=''' occ_«col.name»_«init.pl.name» := 0
 State_«init.pl.name»(«col.name») := 0'''
        }
        return ST
		
	}
	def  compilenotdeclaredcolors(color col, inialisation init){
		var ST = ''''''
		var ArrayList<color> colors = new ArrayList<color>()
		for(elt: init.elements){
			colors.add(elt.colr)
			}
        if(!colors.contains(col)){
        	ST+='''@act_«col.name»_«init.pl.name» occ_«col.name»_«init.pl.name» := 0
        	       @act2_«col.name»_«init.pl.name» State_«init.pl.name»(«col.name») := 0'''
        }
        return ST
		}
	
	
	
	def compile(Opr opr, int i){
		
	var String ST = ""
	if(i==1){
		for(elt : opr.elements){
			var temp = ""
			temp +="occ_"+elt.colr.name+"_"+opr.states.get(0).name
			if (elt.counted)
			temp+= ":= occ_"+elt.colr.name+"_"+opr.states.get(0).name+if(opr.op=='\\')"-"else "+"+elt.count.toString+"\n ||"
			else if( !elt.counted)
			temp+= ":= occ_"+elt.colr.name+"_"+opr.states.get(0).name+if(opr.op=='\\')"-"else "+"+"1\n|| "
			ST +=temp
		}}
		if (i==2){
			for(elt : opr.elements){
			var temp = ""
			temp +="State_"+opr.states.get(0).name
			if(opr.op == "\\/")
			if (elt.counted)
			temp+= ":= State_"+opr.states.get(0).name+"<-|"+"{"+elt.colr.name+ "|->"+elt.count.toString+"}"+"\n ||"
			else if( !elt.counted)
			temp+= ":= State_"+opr.states.get(0).name+"<-|"+"{"+elt.colr.name+ "|->1}\n||"
			else
			temp+= ":= State_"+opr.states.get(0).name+"<-|"+"{"+elt.colr.name+ "|->0}\n||"
			ST +=temp
		}}
		return ST
	}
	
	// define la transformation de la la partie the des garde de la transition en prenant en compte le contexte (int i)
	def compileEB(Opr opr, int i){	
	var String ST = ""
	if(i==1){
		for(elt : opr.elements){
			var temp = ""
			temp +="@act_"+elt.colr.name+opr.states.get(0).name+" occ_"+elt.colr.name+"_"+opr.states.get(0).name
			if (elt.counted)
			temp+= ":= occ_"+elt.colr.name+"_"+opr.states.get(0).name+if(opr.op=='\\')"-"else "+"+elt.count.toString+"\n"
			else if( !elt.counted)
			temp+= ":= occ_"+elt.colr.name+"_"+opr.states.get(0).name+if(opr.op=='\\')"-"else "+"+"1 \n"
			ST +=temp
		}}
		if (i==2){
			for(elt : opr.elements){
			var temp = ""
			temp +="@act_"+opr.states.get(0).name+"  State_"+opr.states.get(0).name
			if (elt.counted)
			temp+= ":= State_"+opr.states.get(0).name+"<-|"+"{("+elt.colr.name+ "|->"+(if(opr.op=='\\/')elt.count.toString else "0")+")}"+"\n ||"
			else if( !elt.counted)
			temp+= ":= State_"+opr.states.get(0).name+"<-|"+"{("+elt.colr.name+(if(opr.op=='\\/')"|->1" else "0")+")}\n"
			ST +=temp
		}}
		return ST
	}
	def compile(Containement con, int i){
		var String ST = ""
		if (i==1)
		for(elt : con.elements){
			var temp = ""
			temp +="occ_"+elt.colr.name+"_"+con.state.name
			if (elt.counted)
			temp+= " >= "+elt.count.toString+" &"
			else if( !elt.counted)
			temp+= " >= 1 & "
			ST +=temp
		}
		else if (i==2)
		for(elt : con.elements){
			var temp = ""
			temp +="occ_"+elt.colr.name+"_"+con.state.name
			if (elt.counted)
			temp+= " >= "+elt.count.toString+" &"
			else if( !elt.counted)
			temp+= " >= 1 & "
			ST +=temp
		}
		else if (i==3)
		for(elt : con.elements){
			var temp = ""
			temp +="@guard_"+elt.colr.name+"_"+con.state.name+"  occ_"+elt.colr.name+"_"+con.state.name
			if (elt.counted)
			temp+= " >= "+elt.count.toString+"\n"
			else if( !elt.counted)
			temp+= " >= 1 \n "
			ST +=temp
		}
		return ST
	}
	def  compile(EList<color> list, int i){
		var iter = list.size
		var j = 1
		var String ST =""
		if(i==0){
		for (c:list){
			if(j == iter){ ST += c.name}
			else{ ST+= c.name+", "}
			j +=1}	
		}
		if (i==1){
			for (c:list){
			if(j == iter){ ST += "{"+c.name+"}"}
			else{ ST+= "{"+c.name+"}, "}
			j +=1}
			
		}
		return ST
	}
	def compile(EList<color> list, Placedec place , int i){
		var String ST =""
		if (i== 1){
		for (c:list)
			{ ST += "occ_"+c.name+"_"+place.name+", "}	
		}
		else if(i==2){for (c:list)
			{ ST += "occ_"+c.name+"_"+place.name+" : NAT, "}	
		}
		else if(i==3){for (c:list)
			{ ST += " occ_"+c.name+"_"+place.name}	
		}
		else if(i==4){for (c:list)
			{ ST += "@inv_"+c.name+place.name+"occ_"+c.name+"_"+place.name+" : NAT \n"}	
		}
		
		return ST
	}
	def compileTr(EList<Transitiondeclation> trans, int i){
		var iter = trans.size
		var j = 1
		var String ST =""
		if(i==1){
		for (c:trans){
			if(j == iter){ ST += " Enabled_"+c.name}
			else{ ST+= " Enabled_"+c.name+","}
			j +=1}
		}
		else if(i == 2){
			for (c:trans){if(j == iter){ ST += " Enabled_"+c.name+" : BOOL"}
			else{ ST+= " Enabled_"+c.name+" : BOOL,"}
			j +=1}
		}
		else if(i == 3){
			for (c:trans){{ ST += " Enabled_"+c.name}}
		}
		else if(i == 4){
			for (c:trans){{ ST += "@inv_"+c.name+" Enabled_"+c.name+" : BOOL \n"}
			}
		}
		return ST
	}
	
	def compilecolors(EList<Placedec> list, int j){
		var ArrayList<String> col = new ArrayList<String>();
		var String ST=""
		var int i
		var int size
		if(j == 1){
		//colorsl.add((list.get(0) as Placedec).colors.get(0))
		for (place : list)
		for (color: place.colors)
		if(col.contains(color.name)){i++}
		else col.add(color.name)
		size = col.size
		i =1
		for (c:col){
		if (i==size) ST+=c
		else ST+= c
		i+=1}}
		else if (j== 2){
		for (place : list)
		for (color: place.colors)
		if(col.contains(color.name)){i++}
		else col.add(color.name)
		size = col.size
		i =1
		for (c:col){
		if (i==size) ST+="{"+c+"}"
		else ST+= "{"+c+"}"
		i+=1}
			
		}
		return ST
	}
}
